      
      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! This program reads cartesian geometry [Agngstrom], potential energy [Hartree],
! forces [Hartree/Bohr], and force constants [Hartree/Bohr^2] from unit INP
! (e.g. generated by program GEN_RP) and fits these to a fourier series.
! Author: Robert Prentner
! Zürich, 18. 3. 2009
! Written in Fortran 90
!
! convetions: structs are written as s_<NAME>
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!declarations!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     
      PROGRAM RPH_FIT
      
      USE structs
	 
	IMPLICIT NONE
	INTEGER :: nx,nq,natoms,nx2,order,nqfit,idip,ndati,ii,ij,jj      
	DOUBLE PRECISION :: amass(maxatoms), grmin,tau(maxpoints)
	DOUBLE PRECISION :: xi(3,3,maxpoints),rot(3,maxpoints),dip(3,maxpoints)
	DOUBLE PRECISION :: dipderiv(3,3,4,101)
        CHARACTER :: REC*100000
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
       TYPE(geom) :: s_geom(maxpoints)
       TYPE(fitflag) :: s_flag
       TYPE(fitgeom) :: s_fit 
       TYPE(fitdip) :: s_dip
      
       
       WRITE (*,*) 'User input:'
       READ (*,*) idip
       IF (idip.ne.0) WRITE (*,*) 'read dipoles', idip
       READ (*,*) natoms
       WRITE (*,*) natoms
       READ (*,*) (amass(i),i=1,natoms)
       WRITE (*,*) 'number of atoms'; WRITE (*,*) natoms
       WRITE(*,*) 'atomic masses :'; WRITE (*,'(f9.3)') (amass(i),i=1,natoms)

        IF ( natoms.lt.1 ) stop 'error: number of atoms 0'
	IF (natoms.GT.maxatoms) STOP 'error: to many atoms for calculation'
        DO i=1,natoms; IF(amass(i).LE.0.0) STOP 'error: check atomic masses'; ENDDO
      
        nx=natoms*3 
        nx2=nx**2
      
        !read input from fort.1
	CALL ReadInput(nx,nq,s_geom,dip,idip)
        
	READ (*,*) nqfit
	nqfit=MAX(nqfit,nq)			!never use less points than in the ab initio calculation
	WRITE (*,*) 'numbers to interpolate: ', nqfit
        READ (*,*) grmin
        WRITE(*,*) 'minimum energy gradient for projection';WRITE(*,'(f9.3)') grmin
	
	!Read in Reaction Path
	DO q=1,nq
	 READ (*,*) tau(q)
	 !WRITE (*,*) tau(q)
	ENDDO
	! WRITe (*,*) 'read dip moment deriv'
	!!!!!!!!!!!!!!!!!!!!!! READ IN DIPOLE DERIVATIVES
      WRITe (*,*)
      k=1
      open (4,FILE='gaussian.out',status='unknown')
      IF (idip.ne.0) THEN
      WRITe (*,*) "read dipole derivatives"
	DO j=1,2000
       READ (4,'(1x,a70)',END=99) rec(k:k+69)
       k=k+70
      ENDDO
   99 CONTINUE
	l=1
        m=1
       ndati=0
       DO j=1,20000
   27  if (rec(m:m).ne.'\'.and.rec(m:m).ne.',') THEN  
          IF (rec(m:m).ne.'=') then    !determine  end of word
          m = m+1
          go to 27 
	 ENDIF 
        ENDIF
        IF(REC(l:m).eq.'DipoleDeriv=') THEN
!                  Now select the next 36 numbers	     
	     ndati =ndati+1
	     WRITe (*,*) ndati, ' :dipole deriv found'
	     DO jj=1,natoms
              DO ij=1,3
              Do ii=1,3
	      l=m+1
	      m=m+1
   37       if (rec(m:m).ne.'\'.and.rec(m:m).ne.',' &
                .and.rec(m:m).ne.'=') then    !determine  end of data set 
              m = m+1
              go to 37 
	      ENDIF
	      READ(REC(l:m-1),*) dipderiv(ij,ii,jj,ndati)
	      ENDDO
	      !WRITE (*,'(3F12.7)') (dipderiv(ij,ii,jj,ndati),ii=1,3)
	     ENDDO
	     ENDDO
	     Write(*,*)
   	     WRITE (*,*) 'dip derivs succesfully read'
	     IF(ndati.eq.nq) GOTO 201
	ELSE
	     l=m+1
	     m=m+1	     
	ENDIF
	IF(ndati.eq.nq) GOTO 201
!IF (ndati.ne.np) 
!     & WRITE(*,*) 'error: number dip!= number on rp',np,ndati
	ENDDO
	201 CONTINUE 
       ENDIF
!!!!!!rotate dipole derivatives
!	DO q=1,nq
!		DO jj=1,4
!		 DO ij=1,3
!		 DIP1=COS(tau(q)/2.)*dipderiv(ij,2,jj,q) - SIN(tau(q)/2.)*dipderiv(ij,1,jj,q) !DIP(1)
!
!      	   DIP(1)=SIN(TAU/2.)*DIP(2)
!     #    		  +COS(TAU/2.)*DIP(1)
!     
!	 DIP(2)=DIP1
!		  !WRITE (*,'(3F12.7)') (dipderiv(ij,ii,jj,q),ii=1,3)
!		 ENDDO 
!		ENDDO 
!	ENDDO
    
	
	! generate rp for tau>180 by inversion
	order=Min(maxorder,nq)
	CALL SymGen(nx,nq,s_geom,tau,dip,dipderiv)      
	!WRITE (*,*) (tau(q),q=1,nq)

	
	!Do q=1,nq; tau(q) = tau(q)+90;ENDDO
	!trafo to main axis system
	CALL MainAxis ( natoms, amass, nq, s_geom,xi,rot,dipderiv)
	WRITE (*,*) 'after MainAxis'
	!CALL PrintGeometry(nx,q,s_geom)
        DO q=1,nq
	  WRITE (*,*) 'coordinate ', q
	  WRITE (*,'(3f12.9)')   ((xi(i,j,q)*0.529,j=1,3),i=1,3)
	  WRITE (*,'(3f12.6)')   (1./rot(j,q),j=1,3)
	ENDDO
	!chck for symmetry w.r.t RP
	!CALL PrintGeometry(nx,nq,s_geom)	
	DO q=1,nq
	        WRITE (*,*) q
		WRITE (*,'(3F9.3)') (dip(j,q),j=1,3)
		WRITE (333,*) q 
		WRITE (333,'(3F15.10)') (dip(j,q),j=1,3) 
		WRITE (333,*) 
		DO jj=1,4
		 DO ij=1,3
		  WRITE (*,'(3F12.7)') (dipderiv(ij,ii,jj,q),ii=1,3)
		 ENDDO 
		WRITE (333,'(9F15.10)') (dipderiv(1,k,jj,q),k=1,3), &
     		(dipderiv(2,k,jj,q),k=1,3), &
                (dipderiv(3,k,jj,q),k=1,3)
		ENDDO 
	ENDDO
	
	CALL ChkSym(nx,nq,s_geom,s_flag)

	! Write output to file

	WRITe (*,'(x,a,i4)') 'order of fit: ', order 
	
	CALL FitGeometries(nx,nq,order,tau,s_geom,s_flag,s_fit)
	CALL FitXI(nq,order,tau,s_fit,xi,rot)
	CALL FitDipoles(nq,order,tau,dip,s_dip)
	CALL WritePar(nx,order,s_fit,s_flag,s_dip)
	CALL WriteRP(nx,nq,nqfit,order,s_geom,s_flag,s_fit) 
	
	END PROGRAM RPH_FIT

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
 
	SUBROUTINE ReadInput(nx,nq,s_geom,dip,idip)
      
        USE structs
        TYPE (geom) :: s_geom(maxpoints)
	DOUBLE PRECISION :: dip(3,maxpoints)
        INTEGER :: nq,nx,idip
        
        DO q=1,maxpoints	  
	     READ(inp,*,END=100)  (s_geom(q)%x0(i),i=1,nx)                !read in positions
	     READ(inp,*)  		   s_geom(q)%v0                                           !read in potential
!	     s_geom(q)%v0 = s_geom(q)%v0*hartree
	     READ(inp,*) (s_geom(q)%grad(i),i=1,nx)         		     !read in gradients
	     READ (inp,*) ((s_geom(q)%ff(i,j),j=1,i),i=1,nx) !read in forcefield
	     DO i=1,nx									   												
      	       ! s_geom(q)%x0(i)=s_geom(q)%x0(i)/a0	             !change positions to bohr radii	
	  		   DO j=1,i
			       s_geom(q)%ff(j,i)=s_geom(q)%ff(i,j)			 !use symmetry of force field matrix
			  ENDDO     
	     ENDDO	
             IF(idip.NE.0) THEn !read in dipole moments
	       READ(inp,*) (dip(j,q),j=1,3)    
	     ENDIF
        ENDDO
100   CONTINUE
        nq=q-1
        WRITE (*,*) nq, 'points along the reaction path read from input'	
	
	END SUBROUTINE ReadInput
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
       
	SUBROUTINE WriteRP(nx,nq,nqfit,order,s_geom,s_flag,s_fit)
      
        USE structs
	USE marqfit
        
	TYPE(geom) :: s_geom(nq)
        TYPE(fitflag) :: s_flag
        TYPE(fitgeom) :: s_fit 
	INTEGER, INTENT(IN) :: nq,nx,nqfit,order
        DOUBLE PRECISION :: tau(nqfit),g(1,nq),vint,xint(nx),gint(nx),ffint(nx,nx)

	
!!!!!!!!!!!!print out the unfitted input!!!!!!!!!!!!!!!!!!!!        
	DO q=1,nq	  
	     WRITE(iout,'(3f14.10)')  (s_geom(q)%x0(i),i=1,nx)                
	     WRITE(iout,*)
	     WRITE(iout,'(f14.10)')  s_geom(q)%v0   
	     WRITE(iout,*)
	     WRITE(iout,'(3f14.10)') (s_geom(q)%grad(i),i=1,nx)         		
	     WRITE(iout,*)
	     WRITE(iout,'(5f14.10)') ((s_geom(q)%ff(i,j),j=1,i),i=1,nx) 
	     WRITE(iout,*)
	ENDDO	
!!!!!!!!!!!!!print out fitted input!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	DO q=1,nqfit
	     tau(q)=360./nqfit*(q-0.5)
	     vint=1.d0
	     Do i=1,nx
	       xint(i)=1.0
	       gint(i)=1.0
	       DO j=1,i
	          ffint(i,j)=1.0
	       ENDDO
	     ENDDO
	     vint= expansion(s_flag%flagv0,tau(q),s_fit%fitv0(:),g,order)
	     DO i=1,nx
		gint(i) = expansion(s_flag%flaggrad(i),tau(q),s_fit%fitgrad(i,:),g,order)
		xint(i)= expansion(s_flag%flagx0(i),tau(q),s_fit%fitx0(i,:),g,order)
		DO j=1,i
		 ffint(i,j)= expansion(s_flag%flagff(i,j),tau(q),s_fit%fitff(i,j,:),g,order)
		ENDDO
	     ENDDO
	     WRITE(8,'(3f16.12)')  (xint(i),i=1,nx)                
	     WRITE(8,*)
	     WRITE(8,'(f14.10)')  vint   
	     WRITE(8,*)
	     WRITE(8,'(3f16.12)') (gint(i),i=1,nx)         		
	     WRITE(8,*)
	     WRITE(8,'(5f16.12)') ((ffint(i,j),j=1,i),i=1,nx) 
	     WRITE(8,*)
	ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     	END SUBROUTINE WriteRP
      
      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!      
 
	SUBROUTINE WritePar(nx,order,s_fit,s_flag,s_dip)
      
        USE structs
        TYPE (fitgeom) :: s_fit
	TYPE(fitflag) :: s_flag
	TYPE (fitdip) :: s_dip
        INTEGER, INTENT(IN) :: nx,order
!!!!!!!!!!!!!!!!WRITE OUT GEOMETRIES ETC.!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!        
        WRITE (pout,'(i3)') s_flag%flagv0
	WRITE (pout,'(3ES)') (s_fit%fitv0(i),i=1,order)
	WRITE (pout,*) '@'
	DO j=1,nx
		WRITE (pout,'(i3)') s_flag%flagx0(j)
		WRITE(pout,'(3ES)') (s_fit%fitx0(j,i),i=1,order)
		WRITE (pout,*) '@'
	ENDDO
	DO j=1,nx
		WRITE (pout,'(i3)') s_flag%flaggrad(j)
		WRITE(pout,'(3ES)') (s_fit%fitgrad(j,i),i=1,order)
		WRITE (pout,*) '@'
	ENDDO
	DO j=1,nx
		DO k=1,j
		 WRITE (pout,'(i3)') s_flag%flagff(j,k)
		 WRITE(pout,'(3ES)') (s_fit%fitff(j,k,i),i=1,order)
		 WRITE (pout,*) '@'
		ENDDO	
	ENDDO
!!!!!!!!!!!!!!WRITE OUT FITTED ROT CONSTANTS AND INV SQRT TOI!!!!!!!!!!!!!!!!!!!!!!!	
	DO j=1,3
		WRITE (pout,'(i3)') s_fit%flagrot(j)
		WRITE(pout,'(3ES)') (s_fit%fitrot(j,i),i=1,order)
		WRITE (pout,*) '@'
	ENDDO	
	DO j=1,3
	 Do i=1,j
		WRITE (pout,'(i3)') s_fit%flagxi(j,i)
		WRITE(pout,'(3ES)') (s_fit%fitxi(j,i,k),k=1,order)
		WRITE (pout,*) '@'
	 ENDDO	
	ENDDO
	
	DO j=1,3
		WRITE (44,'(i3)') s_dip%flagdip(j)
		WRITE(44,'(3ES)') (s_dip%dip(j,i),i=1,order)
		WRITE (44,*) '@'
	ENDDO	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	END SUBROUTINE WritePar
            
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    

	SUBROUTINE SymGen(nx,nq,s_geom,tau,dip,dipderiv)				!doubling reaction path by inversion symmetry, periodic continuation to be included
      
        USE structs
        TYPE (geom) :: s_geom(maxpoints)
        INTEGER :: nq,nx,qalt,qneu
        DOUBLE PRECISION :: tau(2*nq-1),dip(3,nq),dipderiv(3,3,4,nq)
	
        DO q=1,nq-1
	 tau(nq+q) = 360 - tau(nq-q)						 !symmetrize Reaction path
         qneu=nq+q
         qalt=nq-q
         s_geom(qneu)%v0=s_geom(qalt)%v0
	     DO i=1,nx
	     	s_geom(qneu)%x0(i)=-s_geom(qalt)%x0(i)           	   !inversion along coordinates
	     	s_geom(qneu)%grad(i)=s_geom(qalt)%grad(i)        	   !gradients change but IRC not ????	
	  		DO j=1,i
	  		       s_geom(qneu)%ff(i,j)=s_geom(qalt)%ff(i,j)
			       s_geom(qneu)%ff(j,i)=s_geom(qneu)%ff(i,j)	
			ENDDO     
	     ENDDO	  
	     DO j=1,3
	      dip(j,qneu) = -dip(j,qalt)
	      DO ij=1,3
	       DO jj=1,4
	         dipderiv(j,ij,jj,qneu) = dipderiv(j,ij,jj,qalt)
	       ENDDO
	      ENDDO
	     ENDDO
	ENDDO
	WRITE (*,1001) nq+1, 2*nq-1, nq
	nq=(2*nq)-1
	  
	  
1001  format (/1x,79('!')&
              /4x,'SYMGEN: Points ',i3,' to ',i3,&
               ' have been generated by inversion (*).'&
              /12x,'Point ',i3,' is assumed to be invariant.'&
              /1x,79('!')/)
	END SUBROUTINE SymGen
      
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    

	SUBROUTINE PrintGeometry(nx,nq,s)
       
        USE structs
        INTEGER :: nx, nq, iq 	
        TYPE (geom) :: s(nq)
        WRITE(*,*) 'coordinates: '
	WRITE(*,*) nq
	WRITE (*,'(3F9.6)') (s(nq)%x0(i),i=1,nx)
		
      
	END SUBROUTINE PrintGeometry

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!            
      
	SUBROUTINE ChkSym(nx,nq,s,flag)
      
	USE structs
	INTEGER :: nx, nq
	DOUBLE PRECISION :: normf, flagf
	TYPE (geom) :: s(maxpoints)
	TYPE (fitflag) :: flag
         

	CALL ChkFlag (nq,normf,flagf,s%v0)
	CALL AssignFlag (flag%flagv0,flagf)
	
	WRITE(*,*)
	WRITE (*,3001)
	WRITE(*,'(4x,a)') 'CHKSYM: print out the symmetry w.r.t. reaction path'
	WRITE (*,3001)
	WRITE(*,*)
	WRITE (*,'(a)') 'Symmetry of potential: '
	WRITE (*,'(5x,i3)') flag%flagv0
	WRITE(*,*)
         
	DO i=1,nx
		!assign position flags
		CALL ChkFlag (nq,normf,flagf,s%x0(i))
		CALL AssignFlag (flag%flagx0(i),flagf)
		! gradients
		CALL ChkFlag (nq,normf,flagf,s%grad(i))
		CALL AssignFlag (flag%flaggrad(i),flagf)
		!force field
         	DO j=1,i
			CALL ChkFlag (nq,normf,flagf,s(:)%ff(i,j))
			!WRITE (*,*) i,j,flagf
			CALL AssignFlag (flag%flagff(i,j),flagf)
         	ENDDO
	ENDDO
	
	WRITE (*,'(a)') 'Symmetry of coordinates (index,flag)'
	WRITE (*,'(3(i3,2x,i3,5x))') (i,flag%flagx0(i),i=1,nx)
	WRITE (*,*)
	WRITE (*,'(a)') 'Symmetry of gradients (index,flag)'
	WRITE (*,'(3(i3,2x,i3,5x))') (i,flag%flaggrad(i),i=1,nx)
	WRITE (*,*)
	WRITE (*,'(a)') 'Symmetry of force field (index,index, flag)'
	DO i=1,nx;WRITE (*,'(5(2i3,2x,i3,4x))') (i,j,flag%flagff(i,j),j=1,i); ENDDO;
	
	
3001  format (80('!'))
	CONTAINS
	
	SUBROUTINE ChkFlag(nq,normf,flagf,v)
	
	INTEGER :: nq
	DOUBLE PRECISION :: normf,flagf,v(nq)
		normf=0.0
		flagf=0.0
		DO q=1,INT(nq/2)
			flagf=flagf+(v(q)-v(nq+1-q))**2
			normf=normf+v(q)**2+v(nq+1-q)**2		
		ENDDO
		IF(normf.GT.0.) flagf=flagf/(2*normf)
	END SUBROUTINE ChkFlag
	
	SUBROUTINE AssignFlag (flag,flagf)
		INTEGER :: flag
		DOUBLE PRECISION :: flagf
		IF (flagf.LT.0.0.OR.flagf.GT.1.001) THEN; WRITE (*,*) 'ChkSym: Error',flagf; flag=2
		ELSEIF (flagf.LE.0.05) THEN; flag=1
		ELSEIF (flagf.GE.0.95) THEN; flag=-1
		ELSE; flag=0
		END IF
	END SUBROUTINE AssignFlag

	END SUBROUTINE ChkSym
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	SUBROUTINE FitGeometries(nx,nq,order,tau,s_geom,s_flag,s_fit)
	
        USE structs
	USE marqfit
	
	TYPE(geom) :: s_geom(nq)
        TYPE(fitflag) :: s_flag
        TYPE(fitgeom) :: s_fit 
        DOUBLE PRECISION :: tau(nq),ftest,g(1,nq)
	INTEGER :: nq,nx,order
	
	WRITE(*,*)
	WRITE (*,2001)
	WRITE(*,'(4x,a,I4)') 'FitGeometries: (periodic) input gets fitted to a fourier series of order ', order
	WRITE (*,2001)
	WRITE(*,*)
	WRITE (*,'(x,a)') ' potential fitted to cos2 series: '
	WRITE(*,*) ' optimization cycles, points on rp, RMSR'
	
	s_fit%flagv0=1
	CALL SetupFit(tau,s_fit%fitv0,s_geom%v0,nq,order,s_fit%flagv0,ntol,nopt,rmsr)
	IF(rmsr.gt.0.01) WRITE (*,'(a,i4,17x,i4,10x,g11.3)') 'warning: big rmsr',NOPT,ntol,rmsr
	WRITE(*,*)
	WRITE (*,'(x,a)') ' coordinates fitted to sin/cos series: '
	WRITE(*,*) ' optimization cycles, points on rp, RMSR'
	DO i=1,nx
		s_fit%flagx0(i)=s_flag%flagx0(i)
		SELECT CASE (s_fit%flagx0(i))
		CASE (1) 
			CALL SetupFit(tau,s_fit%fitx0(i,:),s_geom%x0(i),nq,order,1,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
		CASE (0)
			CALL SetupFit(tau,s_fit%fitx0(i,:),s_geom%x0(i),nq,order,0,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
		CASE (-1)
			CALL SetupFit(tau,s_fit%fitx0(i,:),s_geom%x0(i),nq,order-1,-1,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
			s_fit%fitx0(i,order)=0.0
		END SELECT	
	ENDDO
	WRITE(*,*)
	WRITE (*,'(x,a)') ' gradients fitted to sin/cos series: '
	WRITE(*,*) ' optimization cycles, points on rp, RMSR'
	DO i=1,nx
		s_fit%flaggrad(i)=s_flag%flaggrad(i)
		SELECT CASE (s_fit%flaggrad(i))
		CASE (1) 
			CALL SetupFit(tau,s_fit%fitgrad(i,:),s_geom%grad(i),nq,order,1,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
		CASE (0)
			CALL SetupFit(tau,s_fit%fitgrad(i,:),s_geom%grad(i),nq,order,0,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
		CASE (-1)
			CALL SetupFit(tau,s_fit%fitgrad(i,:),s_geom%grad(i),nq,order-1,-1,ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
			s_fit%fitgrad(i,order) = 0.0
		END SELECT
	ENDDO
	WRITE(*,*)
	WRITE (*,'(x,a)') ' forces fitted to sin/cos series: '
	WRITE(*,*) ' optimization cycles, points on rp, RMSR'
	DO i=1,nx
		DO j=1,i
		        s_fit%flagff(i,j)=s_flag%flagff(i,j)
			SELECT CASE (s_fit%flagff(i,j))
			CASE (1) 
				CALL SetupFit(tau,s_fit%fitff(i,j,:),s_geom%ff(i,j),nq,order,1,ntol,nopt,rmsr)
				IF(rmsr.gt.0.01) WRITE (*,'(2i4,5x,a,i4,17x,i4,10x,g11.3,i4)') i,j, 'warning: big rmsr',NOPT,ntol,rmsr,1
			CASE (0)
				CALL SetupFit(tau,s_fit%fitff(i,j,:),s_geom%ff(i,j),nq,order,0,ntol,nopt,rmsr)
				IF(rmsr.gt.0.01) WRITE (*,'(2i4,5x,a,i4,17x,i4,10x,g11.3)') i,j, 'warning: big rmsr',NOPT,ntol,rmsr
			CASE (-1)
				CALL SetupFit(tau,s_fit%fitff(i,j,:),s_geom%ff(i,j),nq,order-1,-1,ntol,nopt,rmsr)
				IF(rmsr.gt.0.01) WRITE (*,'(2i4,5x,a,i4,17x,i4,10x,g11.3,i4)') i,j, 'warning: big rmsr',NOPT,ntol,rmsr,-1
				s_fit%fitff(i,j,order)=0.0
			END SELECT
		DO ifit=1,order;	s_fit%fitff(j,i,ifit)=s_fit%fitff(i,j,ifit); ENDDO
		ENDDO	
	ENDDO
	
	
	WRITE(*,*)
	WRITE(*,2001)
	WRITE(*,'(x,a)') 'test for potential'
	WRITE(*,'(4G16.8)') (s_fit%fitv0(i),i=1,order)
	DO q=1,nq
	     ftest=1.d0
	     ftest = expansion(s_fit%flagv0,tau(q),s_fit%fitv0(:),g,order)
	     WRITE(*,'(f6.2,x,2F15.9)') tau(q),s_geom(q)%v0,ftest	     
	ENDDO
	
2001  format (80('!'))
2002  format (40('!'))

	END SUBROUTINE FitGeometries
	
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	SUBROUTINE FitXI(nq,order,tau,s_inertia,xi,rot)
	
        USE structs
	USE marqfit
	
	TYPE(fitgeom) :: s_inertia
        DOUBLE PRECISION :: tau(nq),xi(3,3,nq),rot(3,nq),rtest(3),g(1,nq)
	INTEGER :: nq,order
	
	WRITE(*,*)
	WRITE (*,2001)
	WRITE(*,'(4x,a,I4)') 'FitXI: inverse sqrt of inertia and rotation constants fitted to cos series of order ', order
	WRITE (*,2001)
	WRITE(*,*)
	!WRITE (*,'(x,a)') ' potential fitted to cos2 series: '
	!WRITE(*,*) ' optimization cycles, points on rp, RMSR'
	DO i=1,3
	   s_inertia%flagrot(i)=1 
	   CALL SetupFit(tau,s_inertia%fitrot(i,:),rot(i,:),nq,order,s_inertia%flagrot(i),ntol,nopt,rmsr)
	   IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
	   DO j=1,i
	        s_inertia%flagxi(i,j)=1 
		s_inertia%flagxi(j,i)=1
		CALL SetupFit(tau,s_inertia%fitxi(i,j,:),xi(i,j,:),nq,order,s_inertia%flagxi(i,j),ntol,nopt,rmsr)
		        IF(rmsr.gt.0.01) WRITE (*,'(2i4,5x,a,i4,17x,i4,10x,g11.3)') i,j, 'warning: big rmsr',NOPT,ntol,rmsr
		s_inertia%fitxi(j,i,1:order)=s_inertia%fitxi(i,j,1:order)
	   ENDDO
	ENDDO
	!CALL SetupFit(tau,s_fit%fitx0(i,:),s_geom%x0(i),nq,order-1,-1)
	!CALL SetupFit(tau,s_fit%fitff(i,j,:),s_geom%ff(i,j),nq,order-1,-1)
		
	WRITE(*,*)
	WRITE(*,2001)
	!WRITE(*,'(x,a)') 'test for rot constans'
!	WRITE(*,'(5F12.6)') (s_inertia%fitrot(j,i),i=1,order)
	rtest(1:3)=0.
	DO q=1,nq
	     Do j=1,3
	      !rtest(j)=1.d0
	      rtest(j)= rtest(j) + 0.5*(expansion(s_inertia%flagrot(j),tau(q),s_inertia%fitrot(j,:),g,order) - &
	      expansion(s_inertia%flagrot(j),tau(nq+1-q),s_inertia%fitrot(j,:),g,order))**2
	     ENDDO 
	     !WRITE(*,'(f6.2,x,6f12.6)') tau(q),(rot(j,q),rtest(j),j=1,3)
	ENDDO
	!WRITE (*,'(3ES)') rtest(1:3)
	
	WRITE(*,'(x,a)') 'test for diag elements of I^(-1/2)'
	DO q=1,nq
	     Do j=1,3
	      rtest(j)=1.d0
	      rtest(j)= expansion(s_inertia%flagxi(j,j),tau(q),s_inertia%fitxi(j,j,:),g,order)
	     ENDDO 
	     WRITE(*,'(f6.2,x,6f12.6)') tau(q),(xi(j,j,q),rtest(j),j=1,3)
	ENDDO
	
2001  format (80('!'))
2002  format (40('!'))

	END SUBROUTINE FitXI
     
!***********************************************************************
	SUBROUTINE FitDipoles(nq,order,tau,dip,s_dip)
	
	USE structs
	USE marqfit
	
	TYPE(fitdip) :: s_dip
	INTEGER :: nq,order
	DOUBLE PRECISION :: tau(nq),dip(3,nq)
	
	WRITE(*,*)
	WRITE (*,2001)
	WRITE(*,'(4x,a,I4)') 'FitDipoles: dipole moments fitted to cos series of order ', order
	WRITE (*,2001)
	
	DO i=1,3
	   s_dip%flagdip(i) = -1
	   CALL SetupFit(tau,s_dip%dip(i,:),dip(i,:),nq,order,s_dip%flagdip(i),ntol,nopt,rmsr)
	   IF(rmsr.gt.0.01) WRITE (*,'(i4,5x,a,i4,17x,i4,10x,g11.3)') i, 'warning: big rmsr',NOPT,ntol,rmsr
	ENDDO
	
2001  format (80('!'))	
	END SUBROUTINE FitDipoles

	SUBROUTINE MainAxis ( nat, am, nq, s_geom,xi,rot,dd )

!!!!!!!This subroutine does following steps:!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  -) transform to COM System (SR Inert)
! -) Transform  to Main Axis Szystem (SR tracor with D) 
!!!!!!!!!!!!!!INPUT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! nat...Nr. of Atoms
! am...atomic masses
! nq.....Nr. of RP coordinates
! s_geom... geometries etc.
!!!!!!!!!!!!!!OUTPUT!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! s_geom... geometries etc. in Main Axis system
! xi ... inverse sqrt of tensor of inertia
! rot... main moments of inertia
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 15.05.2010, ROPR
 
	USE structs
        INTEGER :: nq,nx,nat
	DOUBLE PRECISION :: rot(3,q), d(3,3), d2(3,3),d0(3,3),xi(9,nq), xref(3*nat),am(nat)
	DOUBLE PRECISION :: s1,s2, sum,xc(3),xcc(9),dd(3,3,nat,nq)
	TYPE (geom) :: s_geom(nq)
!	DOUBLE PRECISION :: x(3*nat,nq), gr(3*nat,nq),ffield(3*nat*3*nat,nq)

       

	nx = 3*nat
	DO i=1, 3*nat      ! reference axis system
		xref(i) = s_geom(1)%x0(i)
	ENDDO
	DO i=1,3		  !reference coordinate system
	   D0(i,i) = 1.0
	   Do j=1,i-1
		D0(i,j)=0.0
		D0(j,i)=0.0
	   ENDDO
	  ENDDO
	  
	  Do q=1,nq
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! assign Cartesian axes to maximize mass-weighted overlap of XREF and X0!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!this automatically produce the right symmetry for the geomtries w.r.t. inversion!!!!!!!!!!!!!!!!!!!!
        CALL Asn_axes ( nat, am, xref, s_geom(q)%x0(1), d0 )
!	WRITE (*,*) q
!        WRITE (*,*) 'reference D (previous point)'
!	WRITE (*,'(3F9.4)') ((d0(i,j),j=1,3),i=1,3)
!        WRITE (*,*) 'D axis of inertia'
!	WRITE (*,'(3F9.4)') ((d(i,j),j=1,3),i=1,3)
!	WRITE (*,*) 'new assigend axes'
!	WRITE (*,'(3F6.2)') ((d0(i,j),j=1,3),i=1,3)
        CALL Tracor ( nat, s_geom(q)%x0(1:nx), s_geom(q)%grad(1:nx), s_geom(q)%ff(1:nx,1:nx), d0, xi(1,q) ) !!d2
	DO i=1,3*nat       ! new reference axis system
          xref(i) = s_geom(q)%x0(i)
        ENDDO
	DO i=1,3		  !reference coordinate system
	   D0(i,i) = 1.0
	   Do j=1,i-1
		D0(i,j)=0.0
		D0(j,i)=0.0
	   ENDDO
	  ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	  
!!!!!!!!!!!!!!!!!!!!!!!!!!assign D = (D2)^t.D.D2
!	D = MATMUL(TRANSPOSE(D2),MATMUL(D,D2))
!	WRITE (*,*) 'before correct ph'
!	WRITE (*,'(3F9.4)') ((d(i,j),j=1,3),i=1,3)
!!!!!!!!!!!!!avoid phase jumps!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!	CALL CorrectPhase(rot(1,q),D,D0,XC,XCC)
!	WRITE (*,*) 'correct phase:'
!	WRITE (*,'(3F12.6)') ((d(i,j),j=1,3),i=1,3)
!    WRITE (*,'(3F12.6)') (rot(j,q),j=1,3)
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!calculate inverse sqrt tensor of inertia!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
!	Do i = 1 , 3
!         xi(3*i-2,q) = d(i,1) * d(1,1) / sqrt(rot(1,q)) &
!                          + d(i,2) * d(1,2) / sqrt(rot(2,q)) &
!                          + d(i,3) * d(1,3) / sqrt(rot(3,q))
!         xi(3*i-1,q) = d(i,1) * d(2,1) / sqrt(rot(1,q)) &
!                       + d(i,2) * d(2,2) / sqrt(rot(2,q)) &
!		       + d(i,3) * d(2,3) / sqrt(rot(3,q))
!         xi(3*i,q) = d(i,1) * d(3,1) / sqrt(rot(1,q)) &
!                       + d(i,2) * d(3,2) / sqrt(rot(2,q)) &
!		       + d(i,3) * d(3,3) / sqrt(rot(3,q))
!        end do
	  ENDDO
	  
!        CALL PrintGeometry(nx,nq,s_geom)
	DO q=1,nq

! transform to the centre of mass; determine moments of inertia in ROT, 
! main axes in D, and inverse square root of the tensor of inertia in XI
        !WRITE (*,*) 
        !WRITE (*,*) q, ' cordinate trafos '
	CALL Inert( nat, am, s_geom(q)%x0(1), rot(1,q), d, d, xi(1,q) )
	WRITE (*,*) q, 'after inerta' 
	WRITE (*,'(3f12.9)')   (s_geom(q)%x0(i)/0.52917,i=1,nx)
	
	IF (q.eq.1) THEN
	 DO i=1,3
	   Do j=1,3
!		D0(i,j)=D(i,j)		!set reference coordinate system equal to the main axis of q=1
	   ENDDO
	  ENDDO
	ENDIF
	!

	Do i = 1 , 3
         xi(3*i-2,q) = d(i,1) * d(1,1) / sqrt(rot(1,q)) &
                          + d(i,2) * d(1,2) / sqrt(rot(2,q)) &
                          + d(i,3) * d(1,3) / sqrt(rot(3,q))
         xi(3*i-1,q) = d(i,1) * d(2,1) / sqrt(rot(1,q)) &
                       + d(i,2) * d(2,2) / sqrt(rot(2,q)) &
		       + d(i,3) * d(2,3) / sqrt(rot(3,q))
         xi(3*i,q) = d(i,1) * d(3,1) / sqrt(rot(1,q)) &
                       + d(i,2) * d(3,2) / sqrt(rot(2,q)) &
		       + d(i,3) * d(3,3) / sqrt(rot(3,q))
        end do
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!	DO i=1,3		  
!	   D2(i,i) = 1.0
!	   Do j=1,i-1
!		D2(i,j)=0.0
!		D2(j,i)=0.0
!	   ENDDO
!	  ENDDO
	  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! assign Cartesian axes to maximize mass-weighted overlap of XREF and X0!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!this automatically produce the right symmetry for the geomtries w.r.t. inversion!!!!!!!!!!!!!!!!!!!!
!        CALL Asn_axes ( nat, am, xref, s_geom(q)%x0(1), d0 )
!	WRITE (*,*) q
!        WRITE (*,*) 'reference D (previous point)'
!	WRITE (*,'(3F9.4)') ((d0(i,j),j=1,3),i=1,3)
        !WRITE (*,*) 'D axis of inertia'
	!WRITE (*,'(3F9.4)') ((d(i,j),j=1,3),i=1,3)
!	WRITE (*,*) 'new assigend axes'
!	WRITE (*,'(3F6.2)') ((d0(i,j),j=1,3),i=1,3)
!        CALL Tracor ( nat, s_geom(q)%x0(1:nx), s_geom(q)%grad(1:nx), s_geom(q)%ff(1:nx,1:nx), d0, xi(1,q),dd(1:3,1:3,1:nat,q) ) !!d2
!	DO i=1,3*nat       ! new reference axis system
!          xref(i) = s_geom(q)%x0(i)
!        ENDDO
!	DO i=1,3		  !reference coordinate system
!	   D0(i,i) = 1.0
!	   Do j=1,i-1
!		D0(i,j)=0.0
!		D0(j,i)=0.0
!	   ENDDO
!	  ENDDO
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	  
!!!!!!!!!!!!!!!!!!!!!!!!!!assign D = (D2)^t.D.D2
!	D = MATMUL(TRANSPOSE(D2),MATMUL(D,D2))
!	WRITE (*,*) 'before correct ph'
!	WRITE (*,'(3F9.4)') ((d(i,j),j=1,3),i=1,3)
!!!!!!!!!!!!!avoid phase jumps!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IF(q.GE.2) CALL CorrectPhase(rot(1,q),D,D0,XC,XCC)
	!WRITE (*,*) 'after correct phase:'
	!WRITE (*,'(3F12.6)') ((d(i,j),j=1,3),i=1,3)
        !WRITE (*,'(3F12.6)') (rot(j,q),j=1,3)
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!calculate inverse sqrt tensor of inertia!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
!	Do i = 1 , 3
!         xi(3*i-2,q) = d(i,1) * d(1,1) / sqrt(rot(1,q)) &
!                          + d(i,2) * d(1,2) / sqrt(rot(2,q)) &
!                          + d(i,3) * d(1,3) / sqrt(rot(3,q))
!         xi(3*i-1,q) = d(i,1) * d(2,1) / sqrt(rot(1,q)) &
!                       + d(i,2) * d(2,2) / sqrt(rot(2,q)) &
!		       + d(i,3) * d(2,3) / sqrt(rot(3,q))
!         xi(3*i,q) = d(i,1) * d(3,1) / sqrt(rot(1,q)) &
!                       + d(i,2) * d(3,2) / sqrt(rot(2,q)) &
!		       + d(i,3) * d(3,3) / sqrt(rot(3,q))
!        end do
!!!!!!!!!!!!!!!!next: rotate to main axis system!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!	WRITE (*,*) 'tracor'
!	CALL PrintGeometry(nx,q,s_geom)
!	WRITE (*,'(3f12.9)')   (s_geom(q)%x0(i)/0.52917,i=1,nx)
!        WRITE (*,'(3f7.3)')   ((d(i,j),i=1,3),j=1,3)	
	call Tracor (  nat, s_geom(q)%x0(1:nx), s_geom(q)%grad(1:nx), s_geom(q)%ff(1:nx,1:nx), d, xi(1,q) )
!!!!!!!!!!!!!!!!TEST
	WRITE (*,*) 'after tracor'
!	CALL PrintGeometry(nx,q,s_geom)
	WRITE (*,'(3f12.9)')   (s_geom(q)%x0(i)/0.52917,i=1,nx)	
	
!TEST
        sum = 0.0
        s1 = 0.
        s2 = 0.
        DO i = 1 , nat
          DO j = 1 , 3
            k = j + (i-1)*3
            sum = sum + am(i)*xref(k)*s_geom(q)%x0(k)
            s1 = s1 + am(i) * xref(k)**2
            s2 = s2 + am(i) * s_geom(q)%x0(k)**2
          ENDDO
        ENDDO
    
        IF(q.GE.2.AND.sum/dsqrt(s1*s2).LT.0.95) THEN
		write (*,'(x,i4,x,a,f9.4)') q, ' MAKE_NC: XREF.X0 = ', sum/dsqrt(s1*s2)
		!CALL PrintGeometry(nx,q,s_geom)
		WRITE (*,'(3f12.9)')   (xref(i)/0.52917,i=1,nx)
		WRITE (*,'(3f7.3)')   ((d(i,j),i=1,3),j=1,3)	
	ENDIF

        DO i=1,3*nat       ! new reference axis system
          xref(i) = s_geom(q)%x0(i)
        ENDDO
        DO i=1,3		   ! new reference coordinate system 
	   Do j=1,3
		D0(i,j)=D(i,j)
	   ENDDO
	ENDDO
	

	
	ENDDO
	
	
	END SUBROUTINE MainAxis
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine CorrectPhase ( ai, d, d0, xc, xi )

!   16.05.2010 modfied version of SR asn_axes from rph_calc.for (David Luckhaus)
! Called by Inert
! Rearrange main axes to minimize the rotation w.r.t. the reference main axis
! system (d0, usually that of the previous point). 

! Input:
!   AI : main moments of inertia
!   D  : main axes of inertia (eigenvectors of instantaneous tensor of inertia)
!   D0 : reference axis system

! Output:
!   AI : rearranged moments of inertia
!   D  : rearranged main axes system
!   D0 : same as D0 (=reference system for the next point)

! Local:
!   XC : rearranged moments of inertia
!   XI : overlap between the two axis systems
      INTEGER :: i,k,i0,j,i_max,i0_max
      DOUBLE PRECISION :: ai(3), d(3,3), d0(3,3), xc(3), xi(3,3)
      DOUBLE PRECISION :: s_max

      do i = 1 , 3
        do i0 = 1 , 3
          xi(i,i0) = 0.0
          do k = 1 , 3
            xi(i,i0) = xi(i,i0) + d(k,i)*d0(k,i0)
          end do
        end do
      end do
      
!!!!!!!!!!!!!!!!!!!!!!!! ...assign axes in the order of decreasing overlap!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      do k = 1 , 3
        i_max = 1
        i0_max = 1
        s_max = xi(i_max,i0_max)
        do i = 1 , 3
          do i0 = 1 , 3
            if ( abs(xi(i,i0)).gt.abs(s_max) ) then
              i_max = i
              i0_max = i0
              s_max = xi(i_max,i0_max)
            end if
          end do
        end do
        if (abs(s_max).lt.0.9) then
          write (*,'(4x,a,2I4,f8.3,a,a)') ' CorrectPhase: I, I0, S_MAX = ', 		&
                     i_max, i0_max, s_max,					&
                     ' Large rotation angle of main axis system !!'
        end if
	
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ...avoid phase jumps!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        xc(i0_max) = ai(i_max)
        do j = 1 , 3
          if ( s_max.gt.0. ) then 
            d0(j,i0_max) =  d(j,i_max)
          else
            d0(j,i0_max) = -d(j,i_max)
          end if
          xi(j,i0_max) = 0.0
          xi(i_max,j)  = 0.0
        end do
      end do
      do i0 = 1 , 3
        ai(i0) = xc(i0)
        do j = 1 , 3
          d(j,i0) = d0(j,i0)
        end do
      end do

      end

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

      subroutine Asn_axes ( na, amass, xref, x0, d )

! 9.1.2001
! Called by MAIN_AXIS

! Rearrange Cartesian coordinate system to minimize the "distance" of
! mass-weighted Cartesian geometries from a reference geometry (usually that
! of the previous point). 

! Input:
!  NA    : number of atoms
!   AMASS : atomic masses
!   XREF  : reference Cartesian geometry
!   X0    : Cartesian geometry
!   D     : Cartesian basis vectors (e.g. main axes of inertia)

! Output:
!   D     : rearranged axes system

! Local:
!   IAX   : Cartesian axes assignment (x,y,z) --> D(*,IAX(1:3,KSEL))
!   X     : 
!   S     : 
!   D0    : 

      implicit double precision (a-h,o-z)
      dimension amass(na), xref(3,na), x0(3,na), d(3,3)
      dimension x(3), s(3,6), iax(3,6)

      data iax/ 1,2,3,  3,1,2,  2,3,1,  2,1,3,  1,3,2,  3,2,1 /

      do k = 1 , 6
        do i = 1 , 3
          s(i,k) = 0.d0
        end do
      end do

      do ia = 1 , na
        do i = 1 , 3
          x(i) = d(1,i)*x0(1,ia) + d(2,i)*x0(2,ia) + d(3,i)*x0(3,ia)
        end do
        do k = 1 , 6
          do i = 1 , 3
            s(i,k) = s(i,k) + amass(ia) * xref(i,ia) * x(iax(i,k))
          end do
        end do
      end do

! axis system with the highest (mass-weighted) overlap
      ksel = 1
      s2 = 0
      do k = 1 , 6
        test = s(1,k)**2 + s(2,k)**2 + s(3,k)**2
!TEST
!      write (*,*) ' ASN_AXES: ',k,test

        if ( test .gt. s2 ) then
          ksel = k
          s2 = test
        end if
      end do

! rearrange D
      do i = 1 , 3
        do j = 1 , 3
          x(j) = d(i,iax(j,ksel))
        end do
        do j = 1 , 3
          d(i,j) = x(j)
        end do
      end do

! choose phases to maximize overlap without changing the handedness
      sum = s(1,ksel) + s(2,ksel) + s(3,ksel)
      j = 1
      if ( s(2,ksel).gt.s(j,ksel) ) j = 2
      if ( s(3,ksel).gt.s(j,ksel) ) j = 3
      if ( s(j,ksel).gt.sum ) then
        do k = 1 , 3
          if ( k.ne.j ) then
            do i = 1 , 3
              d(i,k) = -d(i,k)
            end do
          end if
        end do
      end if
       
      end subroutine asn_axes

!***********************************************************************
      subroutine Inert ( na, amass, x0, ai, d, xref, xi )

! 12.10.2000
! Called by MAIN_AXIS
! Transform Cartesian coordinates to the centre mass system and calculate
! the inverse square root of the tensor of inertia (XI), the main moments of
! inertia (AI), the eigenvectors of the tensor of inertia (D).

! Input:
!   NA    : number of atoms
!   AMASS : atomic masses [amu]
!   X0    : cartesian geometry
!   XREF  : reference geometry (to assign main axis system to Cartesian axes) 

! Output:
!   X0    : Cartesian centre-of-mass coordinates
!   XI    : inverse square root of the tensor of inertia
!   AI    : main moments of inertia
!   D     : main axis system (=eigenvectors of the tensor of inertia) for the
!           input geometry X0.

! Local:
!   X, XC : working arrays

      implicit double precision  (a-h,o-z)
      dimension x0(3,na), amass(na), xi(3,3), ai(3), xref(3,na)
      dimension x(3), d(3,3), xc(3)

! transform to centre of mass system
      s = amass(1)
      do ia = 2 , na
        s = s + amass(ia)
      end do
      do ix = 1 , 3
        xc(ix) = x0(ix,1) * amass(1)
        do ia = 2 , na
          xc(ix) = xc(ix) + x0(ix,ia) * amass(ia)
        end do
        xc(ix) = xc(ix) / s
        do ia = 1 , na
          x0(ix,ia) = x0(ix,ia) - xc(ix)
        end do
      end do
!      Do j=1,na
!      write (*,"(3F14.10)") (xc(i),i=1,3)
!      ENDDO
! tensor of inertia : XI(1:3,1:3)
      xii=0.
      do i = 1 ,3
        do j = 1 , i
          xi(i,j) = -x0(i,1)*x0(j,1)*amass(1)
          do ia = 2 , na
            xi(i,j) = xi(i,j) - x0(i,ia)*x0(j,ia)*amass(ia)
          end do
          xi(j,i) = xi(i,j)
        end do
        xii = xii - xi(i,i)
      end do
      do i = 1 , 3
        xi(i,i) = xi(i,i) + xii
      end do

! diagonalize tensor of inertia
      call tred2 ( 3, 3, xi, ai, xc, d )
      call tql2 ( 3, 3, ai, xc, d, ierr )

! inverse square root of the tensor of inertia
      DO i=1,3
        DO j=1,i
         	xi(i,i) = d(i,1) * d(j,1) / dsqrt(ai(1)) &
			 + d(i,2) * d(j,2) / dsqrt(ai(2)) &
			 + d(i,3) * d(j,3) / dsqrt(ai(3))
		xi(j,i) = xi(i,j)
        ENDDO
      ENDDO

! make sure the main axis system remains right--handed
!      d(1,3) = d(2,1)*d(3,2) - d(3,1)*d(2,2)
!      d(2,3) = d(3,1)*d(1,2) - d(1,1)*d(3,2)
!      d(3,3) = d(1,1)*d(2,2) - d(2,1)*d(1,2)

      end subroutine inert
      
!************************************************************************

      subroutine Tracor ( na, x0, g, f0, d, xi )

! 14.06.2000
! Called by MAKE_NC (currently not active)
! Transform Cartesian coordinates, forces, force constants and the inverse
! square root of the tensor of inertia to a rotated coordinate axis system.

! Input:
!   NA : number of atoms
!   X0 : Cartesian coordinates
!   G  : Cartesian forces
!   F0 : Cartesian force constant matrix
!   XI : square root of the tensor of inertia
!  DD : Dipolemoment derivatives
!   D  : rotation matrix:  X0 ==> D^t.X0
!                          G  ==> D^t.G
!                          F0 ==> D^t.F0.D
!                          XI ==> D^t.XI.D

! Output:
!   X0 : transformed coordinates      X0 ==> D^t.X0
!   G  : transformed forces           G  ==> D^t.G
!   F0 : transformed force constants  F0 ==> D^t.F0.D
!   XI : transformed square root of the tensor of inertia    XI ==> D^t.XI.D
!   DD : transformed dipole moment derivatives    DD ==> D^t.DD.D

      implicit double precision (a-h,o-z)
      dimension x0(3,na), g(3,na), f0(3,na,3,na), d(3,3), xi(3,3) !,f0(3*na,3*na)
      dimension x(3), xc(3), w(3,3), ff(3*na,3*na)
!      DO i=1,3
!	WRITE(*,'(3g12.5)') ( f0(i,1,j,1),j=1,3)
!      ENDDO
      do ia = 1 , na
        do  i = 1 , 3
          x(i)  = x0(i,ia)
          xc(i) = g(i,ia)
        end do
        do i = 1 , 3
          x0(i,ia) = d(1,i)*x(1)    + d(2,i)*x(2)    + d(3,i)*x(3)
          g(i,ia)  = d(1,i)*xc(1)   + d(2,i)*xc(2)   + d(3,i)*xc(3)
        end do
        do ja = 1 , na
          do i = 1 , 3
            do j = 1 , 3
             w(i,j) = d(1,i) * f0(1,ia,1,ja) * d(1,j) &
                     + d(2,i) * f0(2,ia,1,ja) * d(1,j) &
                     + d(3,i) * f0(3,ia,1,ja) * d(1,j) &
                     + d(1,i) * f0(1,ia,2,ja) * d(2,j) &
                     + d(2,i) * f0(2,ia,2,ja) * d(2,j) &
                     + d(3,i) * f0(3,ia,2,ja) * d(2,j) &
                     + d(1,i) * f0(1,ia,3,ja) * d(3,j) &
                     + d(2,i) * f0(2,ia,3,ja) * d(3,j) &
                     + d(3,i) * f0(3,ia,3,ja) * d(3,j)
!		     w(i,j) = d(1,i) * f0(1+(ia-1)*na,1+(ja-1)*na) * d(1,j) &
!                     + d(2,i) * f0(2+(ia-1)*na,1+(ja-1)*na) * d(1,j) &
!                     + d(3,i) * f0(3+(ia-1)*na,1+(ja-1)*na) * d(1,j) &
!                     + d(1,i) * f0(1+(ia-1)*na,2+(ja-1)*na) * d(2,j) &
!                     + d(2,i) * f0(2+(ia-1)*na,2+(ja-1)*na) * d(2,j) &
!                     + d(3,i) * f0(3+(ia-1)*na,2+(ja-1)*na) * d(2,j) &
!                     + d(1,i) * f0(1+(ia-1)*na,3+(ja-1)*na) * d(3,j) &
!                     + d(2,i) * f0(2+(ia-1)*na,3+(ja-1)*na) * d(3,j) &
!                     + d(3,i) * f0(3+(ia-1)*na,3+(ja-1)*na) * d(3,j)
            end do
          end do
          do i = 1 , 3
             do j = 1 , 3
!	        f0((ja-1)*na+i,(ja-1)*na+j)=w(i,j)	
              f0(i,ia,j,ja) = w(i,j)
             end do
          end do
        end do
      end do	
! inverse square root of the tensor of inertia
      do i = 1 , 3
        do j = 1 , 3
           w(i,j) = d(1,i) * xi(1,1) * d(1,j) &
                  + d(2,i) * xi(2,1) * d(1,j) &
                  + d(3,i) * xi(3,1) * d(1,j) &
                  + d(1,i) * xi(1,2) * d(2,j) &
                  + d(2,i) * xi(2,2) * d(2,j) &
                  + d(3,i) * xi(3,2) * d(2,j) &
                  + d(1,i) * xi(1,3) * d(3,j) &
                  + d(2,i) * xi(2,3) * d(3,j) &
                  + d(3,i) * xi(3,3) * d(3,j)
        end do
      end do
      do i = 1 , 3
        do j = 1 , 3
           xi(i,j) = w(i,j)
        end do
      end do
      


      end subroutine tracor